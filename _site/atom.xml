<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Martin Shwalbe - Hounddog</title>
    <link href="http://hounddog.github.com/atom.xml" rel="self"/>
    <link href="http://hounddog.github.com/"/>
    <updated>2012-11-11T02:46:50+01:00</updated>
    <id>http://hounddog.github.com</id>
    <author>
        <name>Martin Shwalbe</name>
    </author>
    
    <entry>
        <title>Getting Started with REST and Zend Framework 2</title>
        <link href="http://hounddog.github.com/blog/getting-started-with-rest-and-zend-framework-2"/>
        <updated>2012-11-10T00:00:00+01:00</updated>
        <id>http://hounddog.github.com/blog/getting-started-with-rest-and-zend-framework-2</id>
        <content type="html">&lt;div class=&quot;row&quot;&gt;
    &lt;p&gt;
        Today i want to show you how to build a rest application. This tutorials assume you have completed the &lt;a href=&quot;http://zf2.readthedocs.org/en/latest/user-guide/overview.html&quot;&gt;Getting Started&lt;/a&gt;. I will be repeating lot of the steps allready explained in there. There is also a sample Album module which you can install from &lt;a href=&quot;https://github.com/Hounddog/Album&quot;&gt;here&lt;/a&gt;.
    &lt;/p&gt;
    &lt;h1&gt;
        Setting up the Album module
    &lt;/h1&gt;
    &lt;p&gt;
        Start by creating a directory called AlbumRest under module with the following subdirectories to hold the module’s files:
    &lt;/p&gt;
    &lt;pre&gt;
    zf2-tutorial/
        /module
            /AlbumRest
                /config
                /src
                    /AlbumRest
                        /Controller
                /test
    &lt;/pre&gt;

    &lt;p&gt;
        Create Module.php in the AlbumRest module at zf2-tutorial/module/AlbumRest:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;

    namespace AlbumRest;

    class Module
    {
        public function getAutoloaderConfig()
        {
            return array(
                'Zend\Loader\ClassMapAutoloader' =&amp;gt; array(
                    __DIR__ . '/autoload_classmap.php',
                ),
                'Zend\Loader\StandardAutoloader' =&amp;gt; array(
                    'namespaces' =&amp;gt; array(
                        __NAMESPACE__ =&amp;gt; __DIR__ . '/src/' . __NAMESPACE__,
                    ),
                ),
            );
        }

        public function getConfig()
        {
            return include __DIR__ . '/config/module.config.php';
        }
    }
    &lt;/pre&gt;

    &lt;h1&gt;
        Configuration
    &lt;/h1&gt;
    &lt;p&gt;
        Create a file called module.config.php under zf2-tutorial/module/AlbumRest/config:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    return array(
        'controllers' =&amp;gt; array(
            'invokables' =&amp;gt; array(
                'AlbumRest\Controller\AlbumRest' =&amp;gt; 'AlbumRest\Controller\AlbumRestController',
            ),
        ),
        'view_manager' =&amp;gt; array(
            'template_path_stack' =&amp;gt; array(
                'album-rest' =&amp;gt; __DIR__ . '/../view',
            ),
        ),
    );
    &lt;/pre&gt;

    &lt;p&gt;
        As we are in development, we don’t need to load files via the classmap, so we provide an empty array for the classmap autoloader. Create a file called autoload_classmap.php under zf2-tutorial/module/AlbumRest:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    return array();
    &lt;/pre&gt;

    &lt;h1&gt;
        Informing the application about our new module
    &lt;/h1&gt;
    &lt;p&gt;
        We now need to tell the ModuleManager that this new module exists. This is done in the application’s config/application.config.php file which is provided by the skeleton application. Update this file so that its modules section contains the Album module as well, so the file now looks like this:
    &lt;/p&gt;
    &lt;p&gt;
        (Changes required are highlighted using comments.)
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    return array(
        'modules' =&amp;gt; array(
            'Application',
            'Album',
            'AlbumRest',              // &amp;lt;-- Add this line
        ),
        'module_listener_options' =&amp;gt; array(
            'config_glob_paths'    =&amp;gt; array(
                'config/autoload/{,*.}{global,local}.php',
            ),
            'module_paths' =&amp;gt; array(
                './module',
                './vendor',
            ),
        ),
    );
    &lt;/pre&gt;

    &lt;p&gt;
        As you can see, we have added our AlbumRest module into the list of modules after the Album module.
    &lt;/p&gt;
    &lt;p&gt;
        We have now set up the module ready for putting our custom code into it.
    &lt;/p&gt;
    &lt;h1&gt;
        Setup Rest Routing
    &lt;/h1&gt;We need to first add our custom REST routing so we are able to call the RestController. This is the updated module.config.php with the new code highlighted.
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    return array(
        'controllers' =&amp;gt; array(
            'invokables' =&amp;gt; array(
                'AlbumRest\Controller\AlbumRest' =&amp;gt; 'AlbumRest\Controller\AlbumRestController',
            ),
        ),

        // The following section is new and should be added to your file
        'router' =&amp;gt; array(
            'routes' =&amp;gt; array(
                'album-rest' =&amp;gt; array(
                    'type'    =&amp;gt; 'segment',
                    'options' =&amp;gt; array(
                        'route'    =&amp;gt; '/album-rest[/:id]',
                        'constraints' =&amp;gt; array(
                            'id'     =&amp;gt; '[0-9]+',
                        ),
                        'defaults' =&amp;gt; array(
                            'controller' =&amp;gt; 'AlbumRest\Controller\AlbumRest',
                        ),
                    ),
                ),
            ),
        ),

        'view_manager' =&amp;gt; array(
            'template_path_stack' =&amp;gt; array(
                'album-rest' =&amp;gt; __DIR__ . '/../view',
            ),
        ),
    );
    &lt;/pre&gt;
    &lt;p&gt;
        The name of the route is ‘album-rest’ and has a type of ‘segment’. For a RestController we must provide a placeholder in this case the route is `/album-rest/id` which will match any URL that starts with /album-rest. The next segment will be an optional id which is required for the RestController The constraints section allows us to ensure that the characters within a segment are as expected.
    &lt;/p&gt;
    &lt;h1&gt;
        Setup View Strategy
    &lt;/h1&gt;
    &lt;p&gt;
        We are just going to use Json output so i am going to use a view strategy described here by Jurian Sluiman on his &lt;a href=&quot;http://juriansluiman.nl/en/article/119/attach-a-view-strategy-for-specific-modules&quot;&gt;Blog&lt;/a&gt;
    &lt;/p&gt;
    &lt;p&gt;
        Add the strategy to Module.php
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    namespace AlbumRest;

    use Zend\ModuleManager\Feature;         // &amp;lt;-- Add this import
    use Zend\EventManager\EventInterface;   // &amp;lt;-- Add this import
    use Zend\Mvc\MvcEvent;                  // &amp;lt;-- Add this import

    class Module implements
        Feature\BootstrapListenerInterface // Add this Interface
    {
        public function getAutoloaderConfig()
        {
            return array(
                'Zend\Loader\ClassMapAutoloader' =&amp;gt; array(
                    __DIR__ . '/autoload_classmap.php',
                ),
                'Zend\Loader\StandardAutoloader' =&amp;gt; array(
                    'namespaces' =&amp;gt; array(
                        __NAMESPACE__ =&amp;gt; __DIR__ . '/src/' . __NAMESPACE__,
                    ),
                ),
            );
        }

        // Add this Method
        public function onBootstrap(EventInterface $e)
        {
            $app = $e-&amp;gt;getApplication();
            $em  = $app-&amp;gt;getEventManager()-&amp;gt;getSharedManager();
            $sm  = $app-&amp;gt;getServiceManager();

            $em-&amp;gt;attach(__NAMESPACE__, MvcEvent::EVENT_DISPATCH, function($e) use ($sm) {
                $strategy = $sm-&amp;gt;get('ViewJsonStrategy');
                $view     = $sm-&amp;gt;get('ViewManager')-&amp;gt;getView();
                $strategy-&amp;gt;attach($view-&amp;gt;getEventManager());
            });
        }

        public function getConfig()
        {
            return include __DIR__ . '/config/module.config.php';
        }
    }
    &lt;/pre&gt;

    &lt;h1&gt;
        Create the controller
    &lt;/h1&gt;
    &lt;p&gt;
        Let’s go ahead and create our controller class AlbumRestController.php at zf2-tutorials/module/AlbumRest/src/AlbumRest/Controller :
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    namespace AlbumRest\Controller;

    use Zend\Mvc\Controller\AbstractRestfulController;

    class AlbumRestController extends AbstractRestfulController
    {
        public function getList()
        {
            # code...
        }

        public function get($id)
        {
            # code...
        }

        public function create($data)
        {
            # code...
        }

        public function update($id, $data)
        {
            # code...
        }

        public function delete($id)
        {
            # code...
        }
    }
    &lt;/pre&gt;

    &lt;p&gt;
        We have now set up the controller methods to map the HTTP request methods. You can find a detailed explanation of the methods in the &lt;a href=&quot;http://framework.zend.com/manual/2.0/en/modules/zend.mvc.controllers.html#the-abstractrestfulcontroller&quot;&gt;Manual&lt;/a&gt;
    &lt;/p&gt;
    &lt;h1&gt;
        Write the tests
    &lt;/h1&gt;
    &lt;p&gt;
        Our AlbumRest controller doesn’t do much yet, so it should be easy to test.
    &lt;/p&gt;
    &lt;p&gt;
        Create the follwing subdirectories:
    &lt;/p&gt;
    &lt;pre&gt;
    zf2-tutorial/
        /module
            /AlbumRest
                /test
                    /AlbumRestTest
                        /Controller
    &lt;/pre&gt;

    &lt;p&gt;
        Add the 3 files as described in &lt;a href=&quot;http://framework.zend.com/manual/2.0/en/user-guide/routing-and-controllers.html&quot;&gt;Unit Testing&lt;/a&gt; to module/AlbumRest/test
    &lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;Bootstrap.php
        &lt;/li&gt;
        &lt;li&gt;phpunit.xml.dist
        &lt;/li&gt;
        &lt;li&gt;TestConfig.php.dist
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;
        Remember here to change the namespace in Bootstrap.php and change the the ``TestConfig.php.dist.
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    return array(
        'modules' =&amp;gt; array(
            'Album',
            'AlbumRest'
        ),
        'module_listener_options' =&amp;gt; array(
            'config_glob_paths'    =&amp;gt; array(
                '../../../config/autoload/{,*.}{global,local}.php',
            ),
            'module_paths' =&amp;gt; array(
                'module',
                'vendor',
            ),
        ),
    );
    &lt;/pre&gt;
    &lt;p&gt;
        In phpunit.xml change the directory to point at AlbumRestTest
    &lt;/p&gt;
    &lt;p&gt;
        Create zf2-tutorial/Album/module/Album/test/AlbumTest/Controller/AlbumControllerTest.php` with the following contents:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    namespace AlbumRestTest\Controller;

    use AlbumRestTest\Bootstrap;
    use AlbumRest\Controller\AlbumRestController;
    use Zend\Http\Request;
    use Zend\Http\Response;
    use Zend\Mvc\MvcEvent;
    use Zend\Mvc\Router\RouteMatch;
    use Zend\Mvc\Router\Http\TreeRouteStack as HttpRouter;
    use PHPUnit_Framework_TestCase;

    class AlbumRestControllerTest extends PHPUnit_Framework_TestCase
    {
        protected $controller;
        protected $request;
        protected $response;
        protected $routeMatch;
        protected $event;

        protected function setUp()
        {
            $serviceManager = Bootstrap::getServiceManager();
            $this-&amp;gt;controller = new AlbumRestController();
            $this-&amp;gt;request    = new Request();
            $this-&amp;gt;routeMatch = new RouteMatch(array('controller' =&amp;gt; 'index'));
            $this-&amp;gt;event      = new MvcEvent();
            $config = $serviceManager-&amp;gt;get('Config');
            $routerConfig = isset($config['router']) ? $config['router'] : array();
            $router = HttpRouter::factory($routerConfig);
            $this-&amp;gt;event-&amp;gt;setRouter($router);
            $this-&amp;gt;event-&amp;gt;setRouteMatch($this-&amp;gt;routeMatch);
            $this-&amp;gt;controller-&amp;gt;setEvent($this-&amp;gt;event);
            $this-&amp;gt;controller-&amp;gt;setServiceLocator($serviceManager);
        }

        public function testGetListCanBeAccessed()
        {
            $result   = $this-&amp;gt;controller-&amp;gt;dispatch($this-&amp;gt;request);
            $response = $this-&amp;gt;controller-&amp;gt;getResponse();

            $this-&amp;gt;assertEquals(200, $response-&amp;gt;getStatusCode());
        }

        public function testGetCanBeAccessed()
        {
            $this-&amp;gt;routeMatch-&amp;gt;setParam('id', '1');

            $result   = $this-&amp;gt;controller-&amp;gt;dispatch($this-&amp;gt;request);
            $response = $this-&amp;gt;controller-&amp;gt;getResponse();

            $this-&amp;gt;assertEquals(200, $response-&amp;gt;getStatusCode());
        }

        public function testCreateCanBeAccessed()
        {
            $this-&amp;gt;routeMatch-&amp;gt;setParam('id', '1');
            $this-&amp;gt;request-&amp;gt;setMethod('post');

            $result   = $this-&amp;gt;controller-&amp;gt;dispatch($this-&amp;gt;request);
            $response = $this-&amp;gt;controller-&amp;gt;getResponse();

            $this-&amp;gt;assertEquals(200, $response-&amp;gt;getStatusCode());
        }

        public function testUpdateCanBeAccessed()
        {
            $this-&amp;gt;routeMatch-&amp;gt;setParam('id', '1');
            $this-&amp;gt;request-&amp;gt;setMethod('put');

            $result   = $this-&amp;gt;controller-&amp;gt;dispatch($this-&amp;gt;request);
            $response = $this-&amp;gt;controller-&amp;gt;getResponse();

            $this-&amp;gt;assertEquals(200, $response-&amp;gt;getStatusCode());
        }

        public function testDeleteCanBeAccessed()
        {
            $this-&amp;gt;routeMatch-&amp;gt;setParam('id', '1');
            $this-&amp;gt;request-&amp;gt;setMethod('delete');

            $result   = $this-&amp;gt;controller-&amp;gt;dispatch($this-&amp;gt;request);
            $response = $this-&amp;gt;controller-&amp;gt;getResponse();

            $this-&amp;gt;assertEquals(200, $response-&amp;gt;getStatusCode());
        }
    }
    &lt;/pre&gt;
    &lt;p&gt;And execute phpunit from module/AlbumRest/test.&lt;/p&gt;
    &lt;pre&gt;
        PHPUnit 3.7.8 by Sebastian Bergmann.

        .....

        Time: 0 seconds, Memory: 5.25Mb

        OK (5 tests, 5 assertions)
    &lt;/pre&gt;
    &lt;p&gt;
        We are going to consume services from the Album module. Let's start adding in some functionality. In our AlbumRestController add:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function getAlbumTable()
    {
        if (!$this-&amp;gt;albumTable) {
            $sm = $this-&amp;gt;getServiceLocator();
            $this-&amp;gt;albumTable = $sm-&amp;gt;get('Album\Model\AlbumTable');
        }
        return $this-&amp;gt;albumTable;
    }
    &lt;/pre&gt;
    &lt;p&gt;
        You should also add:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
        protected $albumTable;
    &lt;/pre&gt;
    &lt;p&gt;
        Add this test to your AlbumControllerTest class:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function testGetAlbumTableReturnsAnInstanceOfAlbumTable()
    {
        $this-&amp;gt;assertInstanceOf('Album\Model\AlbumTable', $this-&amp;gt;controller-&amp;gt;getAlbumTable());
    }
    &lt;/pre&gt;
    &lt;h2&gt;
        Listing albums
    &lt;/h2&gt;
    &lt;p&gt;
        In order to list the albums, we need to retrieve them from the model and pass them to the view. To do this, we fill in getList() within AlbumRestController. Update the AlbumRestController’s getList() like this:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function getLissrhoadt()
    {
        $results = $this-&amp;gt;getAlbumTable()-&amp;gt;fetchAll();
        $data = array();
        foreach($results as $result) {
            $data[] = $result;
        }

        return array('data' =&amp;gt; $data);
    }
    &lt;/pre&gt;
    &lt;p&gt;
        As we do not have any views for our Controller we need a method on how to test these. For this example i am using curl to test the functionality.
    &lt;/p&gt;
    &lt;pre&gt;
    $ curl -i -H &quot;Accept: application/json&quot; http://zf2-tutorial.localhost/album-rest

    HTTP/1.1 200 OK
    Date: Sat, 10 Nov 2012 19:36:03 GMT
    Server: Apache/2.2.22 (Ubuntu)
    X-Powered-By: PHP/5.4.8-1~precise+1
    Content-Length: 320
    Content-Type: application/json

    {&quot;content&quot;:{&quot;data&quot;:[{&quot;id&quot;:&quot;1&quot;,&quot;artist&quot;:&quot;The  Military  Wives&quot;,&quot;title&quot;:&quot;In  My  Dreams&quot;},{&quot;id&quot;:&quot;2&quot;,&quot;artist&quot;:&quot;Adele&quot;,&quot;title&quot;:&quot;21&quot;},{&quot;id&quot;:&quot;3&quot;,&quot;artist&quot;:&quot;Bruce  Springsteen&quot;,&quot;title&quot;:&quot;Wrecking Ball (Deluxe)&quot;},{&quot;id&quot;:&quot;4&quot;,&quot;artist&quot;:&quot;Lana  Del  Rey&quot;,&quot;title&quot;:&quot;Born  To  Die&quot;},{&quot;id&quot;:&quot;5&quot;,&quot;artist&quot;:&quot;Gotye&quot;,&quot;title&quot;:&quot;Making  Mirrors&quot;}]}}
    &lt;/pre&gt;
    &lt;h1&gt;
        Adding Missing functionality
    &lt;/h1&gt;
    &lt;p&gt;
        Let's add the rest of the functionality to AlbumRestController.
    &lt;/p&gt;
    &lt;h2&gt;
        Get Album
    &lt;/h2&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function get($id)
    {
        $album = $this-&amp;gt;getAlbumTable()-&amp;gt;getAlbum($id);

        return array(&quot;data&quot; =&amp;gt; $album);
    }
    &lt;/pre&gt;
    &lt;p&gt;
        And run curl to see the output.
    &lt;/p&gt;
    &lt;pre&gt;
    $ curl -i -H &quot;Accept: application/json&quot; http://zf2-tutorial.localhost/album-rest/1

    HTTP/1.1 200 OK
    Date: Sat, 10 Nov 2012 19:45:07 GMT
    Server: Apache/2.2.22 (Ubuntu)
    X-Powered-By: PHP/5.4.8-1~precise+1
    Content-Length: 88
    Content-Type: application/json

    {&quot;content&quot;:{&quot;data&quot;:{&quot;id&quot;:&quot;1&quot;,&quot;artist&quot;:&quot;The  Military  Wives&quot;,&quot;title&quot;:&quot;In  My  Dreams&quot;}}}
    &lt;/pre&gt;
    &lt;h2&gt;
        Add Album
    &lt;/h2&gt;We need to modify the AlbumTable in module/Album/src/Album/Model to return the generated id
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function saveAlbum(Album $album)
    {
        $data = array(
            'artist' =&amp;gt; $album-&amp;gt;artist,
            'title'  =&amp;gt; $album-&amp;gt;title,
        );

        $id = (int)$album-&amp;gt;id;
        if ($id == 0) {
            $id =  $this-&amp;gt;tableGateway-&amp;gt;insert($data); //Modify this
        } else {
            if ($this-&amp;gt;getAlbum($id)) {
                $this-&amp;gt;tableGateway-&amp;gt;update($data, array('id' =&amp;gt; $id));
            } else {
                throw new \Exception('Form id does not exist');
            }
        }

        return $id; // Add Return
    }
    &lt;/pre&gt;
    &lt;p&gt;
        Modify the create method in module/AlbumRest/src/AlbumRest/Controller/AlbumRestController as following:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function create($data)
    {
        $form = new AlbumForm();
        $album = new Album();
        $form-&amp;gt;setInputFilter($album-&amp;gt;getInputFilter());
        $form-&amp;gt;setData($data);
        if ($form-&amp;gt;isValid()) {
            $album-&amp;gt;exchangeArray($form-&amp;gt;getData());
            $id = $this-&amp;gt;getAlbumTable()-&amp;gt;saveAlbum($album);
        }

        return $this-&amp;gt;get($id);
    }
    &lt;/pre&gt;
    &lt;pre&gt;
    $ curl -i -H &quot;Accept: application/json&quot; -X POST -d &quot;artist=AC DC&amp;amp;title=Dirty Deeds&quot; http://zf2-tutorial.localhost/album-rest


    HTTP/1.1 200 OK
    Date: Sat, 10 Nov 2012 19:45:07 GMT
    Server: Apache/2.2.22 (Ubuntu)
    X-Powered-By: PHP/5.4.8-1~precise+1
    Content-Length: 88
    Content-Type: application/json

    {&quot;content&quot;:{&quot;data&quot;:{&quot;id&quot;:&quot;1&quot;,&quot;artist&quot;:&quot;The  Military  Wives&quot;,&quot;title&quot;:&quot;In  My  Dreams&quot;}}}
    &lt;/pre&gt;
    &lt;h2&gt;
        Edit Album
    &lt;/h2&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function update($id, $data)
    {
        $data['id'] = $id;
        $album = $this-&amp;gt;getAlbumTable()-&amp;gt;getAlbum($id);
        $form  = new AlbumForm();
        $form-&amp;gt;bind($album);
        $form-&amp;gt;setInputFilter($album-&amp;gt;getInputFilter());
        $form-&amp;gt;setData($data);
        if ($form-&amp;gt;isValid()) {
            $id = $this-&amp;gt;getAlbumTable()-&amp;gt;saveAlbum($form-&amp;gt;getData());
        }

        return $this-&amp;gt;get($id);
    }
    &lt;/pre&gt;
    &lt;pre&gt;
    $ curl -i -H &quot;Accept: application/json&quot; -X PUT -d &quot;artist=Ac-Dc&amp;amp;title=Dirty Deeds&quot; http://zf2-tutorial.localhost/album-rest/1

    HTTP/1.1 200 OK
    Date: Sun, 11 Nov 2012 01:25:11 GMT
    Server: Apache/2.2.22 (Ubuntu)
    X-Powered-By: PHP/5.4.8-1~precise+1
    Content-Length: 70
    Content-Type: application/json

    {&quot;content&quot;:{&quot;data&quot;:{&quot;id&quot;:&quot;1&quot;,&quot;artist&quot;:&quot;Ac-Dc&quot;,&quot;title&quot;:&quot;Dirty Deeds&quot;}}}
    &lt;/pre&gt;
    &lt;h2&gt;
        Delete Album
    &lt;/h2&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
    public function delete($id)
    {
        $this-&amp;gt;getAlbumTable()-&amp;gt;saveAlbum($album);
    }
    &lt;/pre&gt;
    &lt;pre&gt;
    $ curl -i -H &quot;Accept: application/json&quot; -X DELETE http://modules.zendframework.com.dev/album-rest/7

    HTTP/1.1 200 OK
    Date: Sun, 11 Nov 2012 01:28:43 GMT
    Server: Apache/2.2.22 (Ubuntu)
    X-Powered-By: PHP/5.4.8-1~precise+1
    Content-Length: 30
    Content-Type: application/json

    {&quot;content&quot;:{&quot;data&quot;:&quot;deleted&quot;}}
    &lt;/pre&gt;
    &lt;p&gt;
        So now we have turned our Album into a Restfull Application. I wanted to implement a jGrid for this tutorial but i belive that would be suited for a new Module.
    &lt;/p&gt;
    &lt;p&gt;
        The sample source code for this Module can be found &lt;a href=&quot;https://github.com/hounddog/AlbumRest&quot;&gt;here&lt;/a&gt;.
    &lt;/p&gt;
&lt;/div&gt;</content>
    </entry>
    
    <entry>
        <title>Using Traits with Zend Framework 2</title>
        <link href="http://hounddog.github.com/blog/using-traits-in-zend-framework-2"/>
        <updated>2012-11-06T00:00:00+01:00</updated>
        <id>http://hounddog.github.com/blog/using-traits-in-zend-framework-2</id>
        <content type="html">&lt;div class=&quot;row&quot;&gt;
    &lt;p&gt;
        Today i want to show you the usefulness of Traits within ZF 2. Some of you like me are maybe wondering when you want to have the ServiceManager injected you always have to create something like this.
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
      namespace Application\Service;

      use Zend\ServiceManager\ServiceManagerAwareInterface;
      use Zend\ServiceManager\ServiceManager;

      class MyService  implements ServiceManagerAwareInterface
      {
          /**
           * @var ServiceManager
           */
          protected $serviceManager;

          //implement some code here

          /**
           * Retrieve service manager instance
           *
           * @return ServiceManager
           */
          public function getServiceManager()
          {
              return $this-&amp;gt;serviceManager;
          }

          /**
           * Set service manager instance
           *
           * @param ServiceManager $locator
           * @return User
           */
          public function setServiceManager(ServiceManager $serviceManager)
          {
              $this-&amp;gt;serviceManager = $serviceManager;
              return $this;
          }
      }

    &lt;/pre&gt;
    &lt;p&gt;
        This you will probably be doing for many Services. The result... the code becomes bloated. We are not following DRY principles. Instead we are copying and pasting this code all over the place. If the structure changes sometime in the future we have to also replace this everywhere.
    &lt;/p&gt;
    &lt;p&gt;
        If you are using PHP 5.4 You are in luck as you can now use traits. I will not go into detail about traits as there are a good bunch of tutorials out there explaining these and the &lt;a href=&quot;http://php.net/manual/en/language.oop5.traits.php&quot; target=&quot;_blank&quot;&gt;PHP Manual&lt;/a&gt; is also quite extensive on this topic.
    &lt;/p&gt;
    &lt;p&gt;
        I just want to show you a short example here on how you can actually benefit from them.
    &lt;/p&gt;Let's get started creating a trait for ServiceManager. I assume here that you are using the &lt;a href=&quot;https://github.com/zendframework/ZendSkeletonApplication&quot;&gt;ZendSkeletonApplication&lt;/a&gt;.
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;

        namespace Application\Provider;

        use Zend\ServiceManager\ServiceManager;

        trait ProvidesServiceManager
        {
          /**
           * @var ServiceManager
           */
          protected $serviceManager;

          /**
           * Retrieve service manager instance
           *
           * @return ServiceManager
           */
          public function getServiceManager()
          {
              return $this-&amp;gt;serviceManager;
          }

          /**
           * Set service manager instance
           *
           * @param ServiceManager $locator
           * @return User
           */
          public function setServiceManager(ServiceManager $serviceManager)
          {
              $this-&amp;gt;serviceManager = $serviceManager;
              return $this;
          }
        }

    &lt;/pre&gt;
    &lt;p&gt;
        To use this we now go back to our Service and change it as follows:
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;

        namespace Application\Service;

        use Zend\ServiceManager\ServiceManagerAwareInterface;
        use Application\Provider\ProvidesServiceManager;

        class MyService  implements ServiceManagerAwareInterface
        {
            use ProvidesServiceManager;// Insert Trait

            // implement code here....
        }

    &lt;/pre&gt;
    &lt;p&gt;
        And voila, we are now using all the methods from TraitServiceManager within our own service! At the time of writing this Matthew Weier O'Phinney gave me the hint that a trait for EventManager is already existing. Thanks for that.
    &lt;/p&gt;
    &lt;p&gt;
        Let's implement that also in our Service.
    &lt;/p&gt;
    &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;

        namespace Application\Service;

        use Zend\EventManager\EventManagerAwareInterface;
        use Zend\ServiceManager\ServiceManagerAwareInterface;

        use Application\Provider\ProvidesServiceManager;
        use Zend\EventManager\ProvidesEvents;

        class MyService  implements ServiceManagerAwareInterface, EventManagerAwareInterface
        {
            use ProvidesServiceManager, ProvidesEvents; //Insert Multiple Traits

            // implement code here....
        }

    &lt;/pre&gt;
    &lt;p&gt;
        Now we have implement the functionality required for ServiceManager and EntityManager without needing to implement the getters/setter for these!
    &lt;/p&gt;
    &lt;p&gt;
        There are many other useful things for using Traits i can think of like DbMapper implementing a pagination etc etc etc. I hope you enjoyed this little excursion on How traits can be useful in your daily development. Happy Coding!
    &lt;/p&gt;
&lt;/div&gt;
</content>
    </entry>
    
    <entry>
        <title>Zend Framework 1.x + Doctrine Migrations 2.x - How to</title>
        <link href="http://hounddog.github.com/blog/zend-framework-1.x-doctrine-migrations-2.x-how-to"/>
        <updated>2012-10-05T00:00:00+02:00</updated>
        <id>http://hounddog.github.com/blog/zend-framework-1.x-doctrine-migrations-2.x-how-to</id>
        <content type="html">&lt;div class=&quot;row&quot;&gt;
  &lt;p&gt;
    Hello everybody!
  &lt;/p&gt;
  
  &lt;p&gt;
    PEM (on irc freenode #dojo) and me have worked hard to make something useful to you! 
  &lt;/p&gt;
  &lt;p&gt;
    I'm pretty sure some of you already encountered that situation when you feel like poping your eyes out because of incomplete documentations, or lack of help/support... 
    If you are reading this, you most likely were about to throw away your computer in anger... Fear not! We will try to save your day :)
  &lt;p&gt;
  &lt;p&gt;Just follow the steps :&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      You can have a look at my repository on github : &lt;a href=&quot;https://github.com/PEM-FR/Doctrine2-ZendFramework1-Migrations-Setup&quot; title=&quot;Doctrine Migration Scripts&quot; target=&quot;_blank&quot;&gt;Doctrine Migration Scripts for Zend Framework support&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
      You have now two choices : 
      &lt;ul&gt;
        &lt;li&gt;
          Integrates Migrations into your already existing Doctrine folder, in this path : Doctrine/DBAL/Migrations.
        &lt;/li&gt;
        &lt;li&gt;
          Use Migrations as Standalone (in that case jump to step xxx).
        &lt;/li&gt;
      &lt;/ul
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;h3&gt;USING MIGRATIONS INSIDE DOCTRINE FOLDER&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;
      So now basically you should have something like this :
      &lt;ul&gt;
       &lt;li&gt;Doctrine/DBAl/Migrations&lt;/li&gt;
       &lt;li&gt;Doctrine/DBAl/Migrations/Configuration&lt;/li&gt;
       &lt;li&gt;Doctrine/DBAl/Migrations/Tools&lt;/li&gt;
       &lt;li&gt;Doctrine/DBAl/Migrations/Tools/Console&lt;/li&gt;
       &lt;li&gt;Doctrine/DBAl/Migrations/Tools/Console/Command&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;In the *scripts* directory you should have a file called ZendConfiguration.php (if not something went wrong go back to step 1)&lt;/li&gt;
    &lt;li&gt;If you have zend framework installed and running, with doctrine, you might want to create a file called doctrine.php (or whatever you like if you know already what we are talking about, or you could use the one provided in the scripts folder).&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;doctrine.php should look like that (DO NOT FORGET TO EDIT THE FILE AND CHANGE THE PATHS)&lt;/p&gt;
  &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
  // Display errors ?
  //ini_set('display_errors', 1);
  //error_reporting(E_ALL | E_STRICT);

  // Define path to application directory
  // DO NOT FORGET TO EDIT
  defined('APPLICATION_PATH')
      || define('APPLICATION_PATH','/path/to/your/application');

  // Define application environment
  defined('APPLICATION_ENV')
      || define(
          'APPLICATION_ENV',
          (getenv('APPLICATION_ENV') ? getenv('APPLICATION_ENV') : 'development')
      );

  // Ensure library/ is on include_path
  // DO NOT FORGET TO EDIT
  set_include_path(
      '/path/to/where/your/zend/library/is' . PATH_SEPARATOR .
      '/path/to/Doctrine' . PATH_SEPARATOR .
      get_include_path()
  );

  // Requiring a batch of Classes we will need for namespacing
  use Doctrine\Common\ClassLoader,
      Doctrine\DBAL\Tools\Console\Helper\ConnectionHelper,
      Doctrine\ORM\Version,
      Doctrine\ORM\Tools\Console\ConsoleRunner,
      Doctrine\ORM\Tools\Console\Helper\EntityManagerHelper,
      Symfony\Component\Console\Helper\HelperSet,
      Symfony\Component\Console\Helper\DialogHelper,
      Symfony\Component\Console\Application;

  // namespacing migrations commands we will be needing later
  use Doctrine\DBAL\Migrations\Tools\Console\Command\DiffCommand,
      Doctrine\DBAL\Migrations\Tools\Console\Command\ExecuteCommand,
      Doctrine\DBAL\Migrations\Tools\Console\Command\GenerateCommand,
      Doctrine\DBAL\Migrations\Tools\Console\Command\MigrateCommand,
      Doctrine\DBAL\Migrations\Tools\Console\Command\StatusCommand,
      Doctrine\DBAL\Migrations\Tools\Console\Command\VersionCommand;

  // We need the Doctrine ClassLoader to manage autoloading
  require_once 'Doctrine/Common/ClassLoader.php';

  // Load Doctrine
  $classLoader = new ClassLoader('Doctrine');
  $classLoader-&gt;register();

  // Load Symfony tools
  $classLoader = new ClassLoader('Symfony', 'Doctrine');
  $classLoader-&gt;register();

  // Load Migration
  $classLoader = new ClassLoader('Migrations', 'Doctrine/DBAL/');
  $classLoader-&gt;register();

  // Zend_Application
  require_once 'Zend/Application.php';

  // Create application
  // DO NOT FORGET TO EDIT
  $application = new Zend_Application(
      APPLICATION_ENV, '/path/to/application.ini'
  );

  // Bootstrap
  $application-&gt;bootstrap();

  // loading doctrine resource, sometimes called entityManager
  // DO NOT FORGET TO EDIT, set the resource to your entityManager
  $em = $application-&gt;getBootstrap()-&gt;getResource('db');

  // Load doctrine helpers
  $helperSet = new HelperSet(array(
      'db'     =&gt; new ConnectionHelper($em-&gt;getConnection()),
      'em'     =&gt; new EntityManagerHelper($em),
      'dialog' =&gt; new DialogHelper()
  ));

  $cli = new Application('Doctrine Command Line Interface', Version::VERSION);
  $cli-&gt;setCatchExceptions(true);
  $cli-&gt;setHelperSet($helperSet);

  // We are settign the commands to bypass the configuration process and
  // directly use our ZendConfiguration
  // Just make sure to load from where the file actually is
  require_once('ZendConfiguration.php');
  $connexion = $em-&gt;getConnection();
  $zendConfig = new ZendConfiguration($connexion);

  // injecting configurations necessary to our ZendConfiguration
  // Pass the Application.ini Parameters to our Configuration
  $applicationConfig = new Zend_Config(
      $application-&gt;getBootstrap()-&gt;getOptions(), true
  );
  // DO NOT FORGET TO EDIT, if needed
  $zendConfig-&gt;setConfig($applicationConfig-&gt;resources-&gt;db-&gt;migration);
  // Here we just need to put some string because the parameter is not optional
  // though will not need it. Just need to call the function
  $zendConfig-&gt;load('zend');

  // Setting up Migrations Commands
  $diffCmd = new DiffCommand();
  $diffCmd-&gt;setMigrationConfiguration($zendConfig);

  $executeCmd = new ExecuteCommand();
  $executeCmd-&gt;setMigrationConfiguration($zendConfig);

  $generateCmd = new GenerateCommand();
  $generateCmd-&gt;setMigrationConfiguration($zendConfig);

  $migrateCmd = new MigrateCommand();
  $migrateCmd-&gt;setMigrationConfiguration($zendConfig);

  $statusCmd = new StatusCommand();
  $statusCmd-&gt;setMigrationConfiguration($zendConfig);

  $versionCmd = new VersionCommand();
  $versionCmd-&gt;setMigrationConfiguration($zendConfig);


  // Register migration Commands
  $cli-&gt;addCommands(array(
      $diffCmd, $executeCmd, $generateCmd, $migrateCmd, $statusCmd, $versionCmd
  ));

  // Register All Doctrine Commands
  ConsoleRunner::addCommands($cli);

  // Runs console application
  $cli-&gt;run();
  &lt;/pre&gt;
  &lt;p&gt;for some more information you might want to check this article : &lt;a href=&quot;http://victimofbabylon.com/setting-up-doctrine-2-cli-with-zend-framework&quot; title=&quot;Setting up doctrine 2 cli for zend framework&quot; target=&quot;_blank&quot;&gt;Setting up doctrine 2 cli for zend framework&lt;/a&gt;
  &lt;p&gt;
  &lt;p&gt;We now have to tweak your Zend Framework application.ini file. Add these few lines :&lt;/p&gt;
  &lt;pre class=&quot;prettyprint linemus lang-prepro&quot;&gt;
  ; ------------------------------------------------------------------------------
  ; Doctrine Migrations Configuration
  ; ------------------------------------------------------------------------------
  resources.db.migration.name = &quot;YourSoft (development) Database Migrations&quot;
  resources.db.migration.tableName = &quot;doctrine_migration_versions&quot;
  resources.db.migration.namespace = &quot;DoctrineMigrations&quot;
  resources.db.migration.directory = APPLICATION_PATH &quot;/path/to/migrationsClass/directory&quot;
  ;set the following two properties if you want to do manual naming on migration classes
  ;resources.doctrine.migration.migrations.migration1.version = &quot;20111020071337&quot;
  ;resources.doctrine.migration.migrations.migration1.class = &quot;DoctrineMigrations\VersionNewMigration&quot;
  &lt;/pre&gt;
  &lt;p&gt;Now, try running from the scripts directory : &lt;/p&gt;
  &lt;pre class=&quot;prettyprint linemus lang-sh&quot;&gt;
  ~$ php doctrine.php list migrations
  &lt;/pre&gt;
  &lt;p&gt;As a result, you should see the commands available, something like that :&lt;/p&gt;
  &lt;pre class=&quot;prettyprint linemus lang-sh&quot;&gt;
    Doctrine Command Line Interface version 2.2.1

    Usage:
      [options] command [arguments]

    Options:
      --help           -h Display this help message.
      --quiet          -q Do not output any message.
      --verbose        -v Increase verbosity of messages.
      --version        -V Display this program version.
      --ansi              Force ANSI output.
      --no-ansi           Disable ANSI output.
      --no-interaction -n Do not ask any interactive question.

    Available commands for the &quot;migration&quot; namespace:
      migrations:diff       Generate a migration by comparing your...
      migrations:execute    Execute a single migration version up or down manually.
      migrations:generate   Generate a blank migration class.
      migrations:migrate    Execute a migration to a specified version...
      migrations:status     View the status of a set of migrations.
      migrations:version    Manually add and delete migration versions...
    &lt;/pre&gt;

  &lt;p&gt;You are now supposed to cry of joy and let a Victory shout be heard by the whole company :)&lt;/p&gt;
&lt;/div&gt;</content>
    </entry>
    
    <entry>
        <title>My Journey in Continuous Deployment</title>
        <link href="http://hounddog.github.com/blog/continuous-deployment-1"/>
        <updated>2012-10-05T00:00:00+02:00</updated>
        <id>http://hounddog.github.com/blog/continuous-deployment-1</id>
        <content type="html">&lt;div class=&quot;row&quot;&gt;
    &lt;p&gt;
      This will be a series of blogs about Continuous Deployment and how to get there. I will be writing about problems which I am facing and what I am experimenting with.
    &lt;/p&gt;

    &lt;p&gt;
      The target of this is to implement a fully automated system which continuously integrates and deploys our development to production servers.
    &lt;/p&gt;

    &lt;p&gt;
      Our main tool we use for this is &lt;a href=&quot;http://jenkins-ci.org/&quot; title=&quot;jenkins&quot;&gt;Jenkins&lt;/a&gt;. If you are not familiar with this. Please have a look. It has lot of plugins which can help you implement automated strategies.
    &lt;/p&gt;

    &lt;p&gt;So, where am I at the moment?&lt;/p&gt;

    &lt;p&gt;
      We are fairly new at using git and are currently discussing viable options on how to implement a successful strategy for git.
    &lt;/p&gt;

    &lt;p&gt;
      Currently I have implemented the solution given &lt;a href=&quot;http://twasink.net/2011/09/20/git-feature-branches-and-jenkins-or-how-i-learned-to-stop-worrying-about-broken-builds/&quot; title=&quot;here&quot;&gt;here&lt;/a&gt;
    &lt;/p&gt;

    &lt;p&gt;
      This solution is great, all the branches are tracked and tested against the master branch.
      But... this provides us with another problem... What if we do not want every branch to be tested directly or tested against the master branch?
    &lt;/p&gt;

    &lt;p&gt;
      For this I am currently looking at opt-in branches by using a configuration file as described &lt;a href=&quot;http://amokti.me/2011/10/11/automatic-opt-in-branch-building-with-jenkins-and-git-2/&quot; title=&quot;here&quot;&gt;here&lt;/a&gt;
    &lt;/p&gt;

    &lt;p&gt;
      What I find interesting in this approach is that I could also modify it to use different jobs within Jenkins by adding parameters in the config file.
      More about this later as I am not sure which approach I would be finally taking.
    &lt;/p&gt;

    &lt;p&gt;
      So, our branching as described above works and all the branches are automatically pushed to the master. Just that each developer has to wait currently for about 12 minutes to know if anything has failed or is Working as expected.
    &lt;/p&gt;

    &lt;p&gt;I like working fast and getting Results fast. &lt;/p&gt;

    &lt;p&gt;
      I have been toying around with Jenkins to make things work faster but hitting lot of Road blocks on the way.
      As this is a pure php project we are also using phing to create the build.
    &lt;/p&gt;

    &lt;p&gt;
      The first question arises when I look at the build.xml which is one huge build process.
    &lt;/p&gt;

    &lt;p&gt;
      To make the build process faster I need to split this up into tasks which can be run in parallel.
    &lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Cleanup the Workspace&lt;/li&gt;
      &lt;li&gt;Initialize the Database&lt;/li&gt;
      &lt;li&gt;Run Unit Tests&lt;/li&gt;
      &lt;li&gt;Run Integration Tests&lt;/li&gt;
      &lt;li&gt;Run Statistic Analysers (PHPMD, Pdepend etc)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;
      I had a look at Creating Downstream jobs within Jenkins. This is an Interesting Approach but does not suit our needs currently.
    &lt;/p&gt;

    &lt;p&gt;
      A downstream job is a job that executes after the Upstream job is completed.
    &lt;/p&gt;

    &lt;p&gt;
      My first attempt was to have a look at the build pipeline plugin. Works great but the Master job is successful even if the Downstream job fails. So I would never really get a fully broken build through the Downstream jobs.
    &lt;/p&gt;

    &lt;p&gt;
      I am going to check today if it is possible by using the Job Join plugin from Jenkins.
    &lt;/p&gt;

    &lt;p&gt;
      As per the information I have gathered I can run another Job after all the Downstream jobs have Completed which would allow me to aggregate all the final Results.
    &lt;/p&gt;

    &lt;p&gt;
      So, I will get started and let you guys know how it ended very soon!
    &lt;/p&gt;

    &lt;p&gt;
      To be Continued... :)
    &lt;/p&gt;
&lt;/div&gt;</content>
    </entry>
    
    <entry>
        <title>Creating my own page with Jekyll and Github</title>
        <link href="http://hounddog.github.com/blog/creating-my-page-with-jekyll"/>
        <updated>2012-09-29T00:00:00+02:00</updated>
        <id>http://hounddog.github.com/blog/creating-my-page-with-jekyll</id>
        <content type="html">&lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;span12 columns&quot;&gt;
        &lt;h2&gt;Why?&lt;/h2&gt;
        &lt;p&gt;I want to share my thoughts with the community.&lt;/p&gt;
        &lt;p&gt;
            I have been working as a Developer for a long time now without my own page.
            So i decided to create one on Github and with a short discussion thx to &lt;a href=&quot;http://ocramius.github.com/blog/moving-my-blog-to-jekyll/&quot; target=&quot;_blank&quot;&gt;Marco Pivetta &lt;/a&gt;. I copied his page and quickly dived into the code and found it very simple to setup.
        &lt;/p&gt;
        &lt;p&gt;
            Within just a few hours i was able to setup and modify my page. So here i am finally. Keep watching for updates.
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</content>
    </entry>
    
</feed>